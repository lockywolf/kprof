<?xml version="1.0" ?>
<!DOCTYPE book PUBLIC  "-//KDE//DTD DocBook XML V4.1-Based Variant V1.0//EN" "dtd/kdex.dtd" [
	<!ENTITY kprof "<application>KProf</application>">
	<!ENTITY % addindex "IGNORE">
	<!ENTITY % English "INCLUDE" > <!-- change language only here -->


]>

<book lang="&language;">
<bookinfo>
	<title>The KProf Handbook</title>
	<authorgroup>
		<author>
			<firstname>Florent</firstname>
			<surname>Pillet</surname>
			<affiliation>
				<address><email>fpillet@users.sourceforge.net</email></address>
			</affiliation>
		</author>
    <author>
      <firstname>Colin</firstname>
      <surname>Desmond</surname>
      <affiliation>
        <address><email>cdesmond@users.sourceforge.net</email></address>
      </affiliation>
    </author>
	</authorgroup>
	<copyright>
		<year>2000</year>
		<year>2001</year>
		<holder>Florent Pillet</holder>
  </copyright>
  <copyright>
    <year>2002</year>
    <holder>Colin Desmond</holder>
	</copyright>
	<legalnotice>&FDLNotice;</legalnotice>

	<!-- Date and version information of the documentation -->
	<date>14/09/2002</date>
	<releaseinfo>1.4.1</releaseinfo>

	<!-- Abstract about this handbook -->
	<abstract>
		<para>
			&kprof; is a visual tool helping developers to analyze the profiling results generated by code profiling tools.
		</para>
	</abstract>

	<!-- This is a set of Keywords for indexing by search engines. -->
	<keywordset>
		<keyword>KDE</keyword>
		<keyword>KProf</keyword>
		<keyword>Development</keyword>
		<keyword>profile</keyword>
		<keyword>gprof</keyword>
		<keyword>profiling</keyword>
	</keywordset>
</bookinfo>

<!-- The contents of the documentation begin here. -->

<chapter id="introduction">
	<title>Introduction</title>
	<para>
		&kprof; is a visual tool  for developers that displays the execution profiling
		output generated by GNU gprof and other profilers. The output of profilers being
    usually difficult to read (beyond the flat profile information),
    KProf presents the information in list- or tree-views that make the
    execution profiling information very easy to understand. 
	</para>
	<para>
		KProf provides access to the following features:
		<itemizedlist>
			<listitem><para>Flat profile view displays all function / methods and their profiling information</para></listitem>
			<listitem><para>Hierarchical profile view displays a tree for each function / method with the other functions / methods it calls as subelements.</para></listitem>
			<listitem><para>Object profile view, for C++ developers, groups the methods in a tree view by object name.</para></listitem>
      <listitem><para>Call Graph view, a graphical view of the call-tree linked to the Method view.</para></listitem>
      <listitem><para>Method view provides a cross-referenced view of individual methods in more detail.</para></listitem>      
			<listitem><para>Recursive functions carry a special icon to clearly show that they are recursive.</para></listitem>
			<listitem><para>Right-clicking a function or method displays a pop-up with the list of callers and called functions. You can directly go to one of these functions by selecting it in the pop-up menu.</para></listitem>
			<listitem><para>The flat profile view provides an additional filter edit box to filter the display and show only the functions or methods containing the text that you enter.</para></listitem>
		</itemizedlist>
	</para>
	<para>
		KProf is distributed under the GPL license and is available in source code form, for free.
	</para>
</chapter>                                                                            

<chapter id="introduction-to-profiling">
	<title>Introduction To Profiling</title>
	<para>
		A code profiler is a tool that developers use to determine where their code spends its time,
		and where it should be optimized.
	</para>
	<para>
		Once your software is developed, you often want to speed
		up parts of your code to improve the general speed of your application. For that matter,
		you need to know what parts of your program are causing the bottlenecks. Common wisdom
		says that 90% of an application's time is spent in 10% of the code. While not always true,
		this is the reality of a lot of programs and something you are probably aware of if you
		are reading this manual.
	</para>
	<para>
		To get started with profiling, you need to understand what a code profiler can do for you
		and why you should use one. A code profiler produces information about the time spent during
		execution in the various parts of your code. It typically gives you the number of times a
		routine is called, who called it and which routines it did in turn call. In addition to the
		number of times the routine was executed, the profiler indicates how much time was spent in
		the routine itself and how much total time was spent in the routine and in the subroutines
		it called.
	</para>
</chapter>

<chapter id="available-profilers">
	<title>Available Profilers</title>
	<para>
		The most widely available profiler on Unix platforms is <ulink url="info:/gprof">gprof</ulink>,
		the GNU profiler. A respectable and long-available tool, gprof may not be enough for you if your
		are trying to do very fine tuning of a complex program with lots of small routines. This is because
		the time measurements given by gprof are statistical, which means that it only gives you a sampling
		of the time spent in the various parts of your programs, not a real and accurate view, especially if
		your program runs for a very short period of time.
	</para>
	<para>
		A new profiler recently appeared on Linux. It is called Function Check
    (currently only version 1.4 is supported) and is available
		<ulink url="http://www.sourceforge.net/projects/fnccheck">here</ulink>. This profiler
		brings numerous improvement over its ancestor. Instead of producing statistical results, it generates
		real measurements of the time spent in routines. For that matter, it uses a technic known as 
		function instrumentation. Briefly, you compile your code with a special switch (specific to GCC,
		so you'll have to use gcc 2.95 or later) which adds calls to the profiler on entry and exit of
		every function. Then at link time, you link with the Function Check library. After executing your
		application, a file named <filename>fnccheck.out</filename> is produced and contains the profiling results.
	</para>
	<para>
		Finally, KProf supports profiling for Palm OS applications executed in POSE, the Palm OS
		Emulator. If you use Unix to develop applications for Palm OS, you can take advantage of
		KProf to examine profiling results generated by POSE.
	</para>
	<para>
	  Links:
	  <itemizedlist>
		<listitem><para><ulink url="http://www.gnu.org/software/binutils/binutils.html">GNU gprof</ulink> (part of the binutils package)</para></listitem>
		<listitem><para><ulink url="http://sourceforge.net/projects/fnccheck">Function Check</ulink> - a better profiler for Unix platforms</para></listitem>
		<listitem><para><ulink url="http://www.palmos.com/dev/tech/tools/emulator">Palm OS Emulator</ulink> - an emulator for Palm OS applications which can also generate profiling information</para></listitem>
	  </itemizedlist>
	</para>
</chapter>

<chapter id="using-kprof">
 <title>Using KProf</title>
 <sect1 id="using-with-gprof">
	<title>Using KProf with GNU gprof</title>
	<para>
		gprof(1) is the most widely available profiler for unix platforms. When you are compiling
		software using GCC, you can use the <option>-pg</option> option to enable profiling in the code
		generated by the compiler. Please refer to the <ulink url="info:/gcc">gcc manual</ulink> for more
		information about profiling switches.
	</para>
	<para>
		When you execute an application compiled with profiling turned on, a file named <filename>gprof.out</filename>
		is generated after execution. If a file with the same name already exists, it is overwritten.
		Please refer to the gprof documentation for more information about this (type 
		<command><ulink url="info:/gprof">info gprof</ulink></command>).
	</para>
	<para>
		Once you have the <filename>gprof.out</filename> generated, you can start using KProf. If the file is
		in the same directory than the application, then you can directly open the application itself
		using KProf. The <filename>gprof.out</filename> file will be automatically detected and analyzed.
	</para>
	<para>
		In the case the <filename>gprof.out</filename> file is in another directory, you must either move it
		to the application directory or manually execute the gprof(1) command to generated the text
		output that KProf needs, using this command:
	</para>
	<para>
<screen width="40">
<prompt>%</prompt> <userinput><command>gprof</command> <option>-b</option> <replaceable>application-name</replaceable> gmon.out > <replaceable>results-file.txt</replaceable></userinput>
</screen>
	</para>
	<para>
		Now you can open the text results file with KProf, making sure that you select <guilabel>GNU gprof</guilabel> as
		the file type at bottom of the Open File dialog.
	</para>
 </sect1>

 <sect1 id="using-with-fnccheck">
	<title>Using KProf with Function Check</title>
	<para>
		Function Check is a profiler that recently appeared on unix platforms. When you are compiling
		software using GCC, you can use the <option>-finstrument-functions</option> option to enable
		profiling in the code generated by the compiler. At link time, you'll have to link with the
		Function Check library (<filename>libfnccheck.a</filename>). Please refer to the Function Check
		documentation for more information about compiling and linking.
	</para>
	<note><para>Function Check currently works with gcc 2.95 and above only.</para></note>
	<para>
		When you execute an application compiled with profiling turned on, a file named <filename>fnccheck.out</filename>
		is generated after execution. If a file with the same name already exists, it is overwritten.
		Please refer to the Function Check documentation for more information about this.
	</para>
	<para>
		Once you have the <filename>fnccheck.out</filename> generated, you can start using KProf. If the file is
		in the same directory than the application, then you can directly open the application itself
		using KProf. The <filename>fnccheck.out</filename> file will be automatically detected and analyzed.
	</para>
	<para>
		In the case the <filename>fnccheck.out</filename> file is in another directory, you must either move it
		to the application directory or manually execute the <ulink url="man:/fncdump">fncdump</ulink> command to
		generated the text output that KProf needs, using this command:
	</para>
	<para>
<screen width="40">
<prompt>%</prompt> <userinput><command>fncdump</command> <option>+calls</option> <option>-no-decoration</option> <option>-sfile fnccheck.out</option> <replaceable>application-name</replaceable> > <replaceable>results-file.txt</replaceable></userinput>
</screen>
	</para>
	<para>
		Now you can open the text results file with KProf, making sure that you select <guilabel>Function Check</guilabel> as
		the file type at bottom of the Open File dialog.
	</para>
 </sect1>

 <sect1 id="using-with-POSE">
	<title>Using KProf with the Palm OS Emulator</title>
	<para>
		If you develop PalmOS applications, you probably know that the Palm OS Emulator (also known
		as POSE) can generate profile information while exeuction your application. For this, you'll
		need to compile the emulator with the <option>--enable-palm-profile</option> option. Please
		refer to the <command>./configure --help</command> in the Palm OS Emulator's <filename>BuildUnix</filename>
		directory.
	</para>
	<para>
		When using POSE, you'll notice that there is a <guimenu>Profiling</guimenu> menu. When in the
		emulator, you can start profiling your application by selecting the <guimenuitem>Start</guimenuitem>
		item. When you are done profiling the wanted part of your application, select the
		<guimenuitem>Stop</guimenuitem> then select the <guimenuitem>Dump</guimenuitem> item in the
		<guimenu>Profiling</guimenu> menu to dump the profile results.
	</para>
 </sect1>
</chapter>

<!-- COMMAND REFERENCE -->
<chapter id="commands">
	<title>Command Reference</title>

	<sect1 id="kprof-mainwindow">
	<title>The main window</title>
		<para>
			The main window consists three lists, accessible using the tabs at top of the window. Each lists
			presents the profile reults in a different way, and serves a different purpose:
			<itemizedlist>
				<listitem><para>The Flat list displays all profile entries one after the other</para></listitem>
				<listitem><para>The Hierarchical list displays each entry as an expandable tree. Child items are the called functions.</para></listitem>
				<listitem><para>The Object list displays methods grouped by C++ class name. This is useful only if you are profiling C++ code.</para></listitem>
        <listitem><para>The Call-graph view offers a grpahical view of the call-tree.
        Requires GraphViz (<ulink url="http://www.graphviz.org">homepage</ulink>) to be installed.</para></listitem>
        <listitem><para>The Method view is a cross-referenced view of individual methods, in more detail, driven by the Call-graph view.</para></listitem>
			</itemizedlist>
			When comparing two profile results, each number column is duplicated to display the old and new results.
		</para>
		<para>
			Each list displays the same columns. You can click on the colum title to sort using this column, click a second time to change the sort
			order (ascending or descending). Here is a brief description of the columns:
			<itemizedlist>
				<listitem><para>Function/Method: displays the function or method name. If the function is recursive, 
								a <inlinemediaobject><imageobject><imagedata fileref="redo.png" format="PNG"/></imageobject></inlinemediaobject>
								icon is displayed in front of the name.</para></listitem>
				<listitem><para>Count: the total number of times the function was called.</para></listitem>
				<listitem><para>Total (s): the total time (in seconds) the function ran, including calls to subroutines.</para></listitem>
				<listitem><para>%: the percent of total CPU time for the process that was used by this function and the subroutines it called.</para></listitem>
				<listitem><para>Self (s): the number of seconds used by the routine itself, excluding calls to the subroutines.</para></listitem>
				<listitem><para>Total us/call: average number of microseconds per call, including calls to the subroutines.</para></listitem>
				<listitem><para>Self us/call: average number of microseconds per call, excluding calls to the subroutines.</para></listitem>
				<listitem><para>Self cycles: if profiler gives the information, number of cycles used by the function excluding calls to the subroutines.</para></listitem>
				<listitem><para>Total cycles: if profiler gives the information, number of cycles used by the function including calls to the subroutines.</para></listitem>
			</itemizedlist>
		</para>
		<tip>
			<para>
				When right-clicking a function name, a pop-up menu appears with a list of functions called by this one (if any) and a list of functions that this
				one calls (if any). You can select one of these functions to go directly to it in the main window.
			</para>
		</tip>
	</sect1>

	<sect1 id="file-menu">
	<title>The File Menu</title>
		<para>
			<variablelist>
				<varlistentry>
					<term>
						<menuchoice>
							<shortcut><keycombo><keycap>Ctrl</keycap><keycap>o</keycap></keycombo></shortcut>
							<guimenu>File</guimenu>
							<guimenuitem>Open</guimenuitem>
						</menuchoice>
					</term>
					<listitem>
						<para>
							<action>Opens a profile results file</action>
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>
						<menuchoice>
							<shortcut><keycombo><keycap>Ctrl</keycap><keycap>r</keycap></keycombo></shortcut>
							<guimenu>File</guimenu>
							<guimenuitem>Open Recent</guimenuitem>
						</menuchoice></term>
					<listitem>
						<para>
							<action>Accesses a recently opened document</action>
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>
						<menuchoice>
							<guimenu>File</guimenu>
							<guimenuitem>Compare With...</guimenuitem>
						</menuchoice></term>
					<listitem>
						<para>
							<action>Opens a results file and compares profile results. The window will show two columns for each number to show differences</action>
						</para>
					</listitem>
				</varlistentry>
				<varlistentry>
					<term>
						<menuchoice>
							<shortcut><keycombo><keycap>Ctrl</keycap><keycap>q</keycap></keycombo></shortcut>
							<guimenu>File</guimenu>
							<guimenuitem>Quit</guimenuitem>
						</menuchoice>
					</term>
					<listitem>
						<para>
							<action>Quits</action> &kprof;
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</para>
	</sect1>

	<sect1 id="tools-menu">
	<title>The Tools Menu</title>
	<para>
		<variablelist>
			<varlistentry>
				<term>
					<menuchoice>
						<shortcut><keycombo><keycap>Ctrl</keycap><keycap>g</keycap></keycombo></shortcut>
						<guimenu>Tools</guimenu>
						<guimenuitem>Generate Call Graph</guimenuitem>
					</menuchoice>
				</term>
				<listitem>
					<para>
						<action>Opens the call-graph output dialog</action>
          </para>
          <para>
            This dialog offers the user the opportunity to save entire or sections of the
            call-tree in graphical format, generated by either GraphViz or VCG.
					</para>
				</listitem>
			</varlistentry>
		</variablelist>
	</para>
	</sect1>

<sect1 id="settings-menu">
<title>The Settings Menu</title>
<para>
	<variablelist>
		<varlistentry>
			<term>
				<menuchoice>
					<shortcut><keycombo><keycap>Ctrl</keycap><keycap>t</keycap></keycombo></shortcut>
					<guimenu>Settings</guimenu>
					<guimenuitem>Show Toolbar</guimenuitem>
				</menuchoice>
			</term>
			<listitem>
				<para>
					<action>Show/Hide the toolbar</action>
				</para>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>
				<menuchoice>
					<shortcut><keycombo><keycap>Ctrl</keycap><keycap>b</keycap></keycombo></shortcut>
					<guimenu>Settings</guimenu>
					<guimenuitem>Abbreviate C++ templates</guimenuitem>
				</menuchoice>
			</term>
			<listitem>
				<para>
					<action>Turn C++ template abbreviation ON or OFF. If enabled, C++ template names are shortened</action>	
				</para>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>
				<menuchoice>
					<shortcut><keycombo><keycap>Ctrl</keycap><keycap>t</keycap></keycombo></shortcut>
					<guimenu>Settings</guimenu>
					<guimenuitem>Select Font</guimenuitem>
				</menuchoice>
			</term>
			<listitem>
				<para>
					<action>Opens the font selection dialog to select the font used to display profile entries</action>
				</para>
			</listitem>
		</varlistentry>
	</variablelist>
</para>
</sect1>
</chapter>


<!-- FAQ -->
<chapter id="faq">
	<title>Questions and Answers</title>
	<qandaset id="faqlist">
		<qandaentry>
			<question>
				<para>How do I specify which profiler generated the profile results?</para>
			</question>
			<answer>
				<para>When you open a file using the Open... menu command, check the appropriate profiler name
				in the buttons at the bottom of the File Open dialog.</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>What happens when I open an application with &kprof;?</para>
			</question>
			<answer>
				<para>&kprof; first looks for a file name <filename>gmon.out</filename> in the same directory. If the file is
				found, &kprof; assumes that the program was compiled with GNU gprof profiling turned on
				(option <option>-pg</option> in GCC) and calls <command>gprof</command> to generate the actual profile results. If the file
				is not found, &kprof; looks for another file name <filename>fncdump.out</filename> which is the results of
				execution profiling generated by Function Check. If found, &kprof; calls fncdump to
				generate the actual results file. These operations are fully automated, all you have to
				do is open the executable and let &kprof; do the work for you.</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>Why is &kprof; slow when I open a Palm OS profile results file?</para>
			</question>
			<answer>
				<para>Profile results generated by POSE (the Palm OS Emulator) require that &kprof; uses
				function name comparisons to retrieve each function's entry. This makes the parsing of
				such files a bit slow.</para>
			</answer>
		</qandaentry>
		<qandaentry>
			<question>
				<para>When I try opening my text results file, &kprof; keeps telling me that it cannot open it.</para>
			</question>
			<answer>
				<para>Make sure that the 'x' (executable) bit is not set on your file. If in doubt, do <command>chmod -x yourfile</command>.</para>
			</answer>
		</qandaentry>
	</qandaset>
</chapter>

<!-- COMMAND LINE PARAMETERS -->

<chapter id="command-line">
<title>Command line parameters</title>
<para>
	&kprof; has two command line parameters,which must occur together or not at all. They allow the user
  to specify which executable they wish to profile (same as File->Open) and which profiler they
  wish to use.
</para>
<para>
  kprof -f [file] -p [gprof, fnccheck, pose]
</para>
</chapter>

<!-- CREDITS AND LICENSE -->

<chapter id="credits">
<title>Credits and License</title>
<para>
	&kprof;
</para>
<para>
	Program copyright 2000-2001 Florent Pillet <email>fpillet@users.sourceforge.net</email>
</para>
<para>
  Additional software and documentation copyright 2002 Colin Desmond
  <email>cdesmond@users.sourceforge.net</email>
</para>
<para>
	Contributors:
	<itemizedlist>
		<listitem><para>Bernd Gehrman <email>bernd@physik.hu-berlin.de</email>: bugfixes and tweaks</para></listitem>
		<listitem><para>Carsten Branitzki <email>csb@operamail.com</email>: tweaks</para></listitem>
		<listitem><para>Ben Burton <email>bab@debian.org</email>: Debian packaging</para></listitem>
	</itemizedlist>
</para>

<para>
	Documentation copyright 2001 Florent Pillet <email>fpillet@users.sourceforge.net</email>
</para>

&underFDL;	<!-- FDL: do not remove -->
&underGPL;	<!-- GPL License -->

</chapter>

<appendix id="installation">
<title>Installation</title>

<sect1 id="getting-kprof">
<title>How to obtain KProf</title>
<para>
The KProf homepage is located at
<ulink url="http://kprof.sourceforge.net/">http://kprof.sourceforge.net</ulink>.
From this page, you can download the source code for the latest release of KProf.
</para>
<para>
If you want to contribute, you can also download the up-to-date source code from
the KProf CVS. The KProf project summary page at
<ulink url="http://sourceforge.net">SourceForge</ulink> is located at
<ulink url="http://sourceforge.net/projects/kprof">http://sourceforge.net/projects/kprof</ulink>.
From this page, you'll find links to browser the CVS repository using a web browser, and
instructions for getting the up-to-date sources via CVS.
</para>
</sect1>

<sect1 id="requirements">
<title>Requirements</title>
<para>
KProf is a KDE 3 application. In order to use it, you need the KDE Libraries available for
free from the <ulink url="http://www.kde.org/">KDE Web Site</ulink>.
</para>
<para>
In addition to KDE, in order to be able to use the Graph-view pane, you need to have
<ulink url="http://www.graphviz.org">GraphViz</ulink> system installed and if you wish to
use the <ulink url="http://rw4.cs.uni-sb.de/users/sander/html/gsvcg1.html">VCG</ulink> system
for saving call-trees then obviously this needs installing too.
</para>
</sect1>

<sect1 id="compilation">
<title>Compilation and installation</title>

<para>
In order to compile and install KProf on your system, type the following in the base
directory of the distribution:
<screen width="40">
<prompt>%</prompt> <userinput>./configure</userinput>
<prompt>%</prompt> <userinput>make</userinput>
<prompt>%</prompt> <userinput>su - root</userinput>
<prompt>#</prompt> <userinput>make install</userinput>
</screen>
</para>

<para>
Since KProf uses autoconf and automake you should have not trouble compiling it.
Should you run into problems please report them to the 
<ulink url="http://sourceforge.net/bugs/?group_id=10250">KProf project page</ulink>.
</para>

</sect1>

</appendix>

&documentation.index;
</book>

